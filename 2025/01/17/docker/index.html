<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="My blog" type="application/atom+xml" />






<meta name="description" content="基础镜像与容器 当我们利用Docker安装应用时，Docker会自动搜索并下载应用镜像(image)。镜像不仅包含应用本身，还包含应用运行所需要的环境、配置、系统函数库。Docker会在运行镜像时创建一个隔离环境，称为容器(container)。 镜像仓库：存储和管理镜像的平台，Docker官方维护的一个公共仓库：Docker Hub 常见命令命令介绍Dcoker最常见的命令就是操作就镜像、容器的">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="https://a1smile.github.io/blog/2025/01/17/docker/index.html">
<meta property="og:site_name" content="My blog">
<meta property="og:description" content="基础镜像与容器 当我们利用Docker安装应用时，Docker会自动搜索并下载应用镜像(image)。镜像不仅包含应用本身，还包含应用运行所需要的环境、配置、系统函数库。Docker会在运行镜像时创建一个隔离环境，称为容器(container)。 镜像仓库：存储和管理镜像的平台，Docker官方维护的一个公共仓库：Docker Hub 常见命令命令介绍Dcoker最常见的命令就是操作就镜像、容器的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99\%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%9F%B9%E8%AE%AD\%E8%BF%90%E7%BB%B4\image\image-20250117153209558.png">
<meta property="og:image" content="d:\%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99\%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%9F%B9%E8%AE%AD\%E8%BF%90%E7%BB%B4\image\image-20250117165816320.png">
<meta property="article:published_time" content="2025-01-17T14:52:34.000Z">
<meta property="article:modified_time" content="2025-01-17T14:52:52.289Z">
<meta property="article:author" content="代洪嵩">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99\%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%9F%B9%E8%AE%AD\%E8%BF%90%E7%BB%B4\image\image-20250117153209558.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://a1smile.github.io/blog/2025/01/17/docker/"/>





  <title>docker | My blog</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">A personal blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://a1smile.github.io/blog/2025/01/17/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">docker</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-01-17T22:52:34+08:00">
                2025-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>镜像与容器</p>
<p>当我们利用Docker安装应用时，Docker会自动搜索并下载应用<strong>镜像(image)</strong>。镜像不仅包含应用本身，还包含应用运行所需要的环境、配置、系统函数库。Docker会在运行镜像时创建一个隔离环境，称为<strong>容器(container)</strong>。</p>
<p><strong>镜像仓库：</strong>存储和管理镜像的平台，Docker官方维护的一个公共仓库：Docker Hub</p>
<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><p>Dcoker最常见的命令就是操作就镜像、容器的命令</p>
<p><img src="D:\学习资料\实验室培训\运维\image\image-20250117153209558.png" alt="image-20250117153209558"></p>
<table>
<thead>
<tr>
<th>docker命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker pull</td>
<td>从镜像仓库拉取到本地镜像</td>
</tr>
<tr>
<td>docker push</td>
<td>推送镜像到DockerRegistry</td>
</tr>
<tr>
<td>docker images</td>
<td>查看本地所有镜像</td>
</tr>
<tr>
<td>docker rmi</td>
<td>删除本地镜像</td>
</tr>
<tr>
<td>docker run</td>
<td>创建并运行容器（不能重复创建）</td>
</tr>
<tr>
<td>docker stop</td>
<td>停止指定容器</td>
</tr>
<tr>
<td>docker start</td>
<td>启动指定容器</td>
</tr>
<tr>
<td>docker ps</td>
<td>查看docker的正在运行的容器  -a:展示所有容器</td>
</tr>
<tr>
<td>docker rm</td>
<td>删除指定容器</td>
</tr>
<tr>
<td>docker logs</td>
<td>查看docker运行日志  -f：持续查看日志</td>
</tr>
<tr>
<td>docker exec</td>
<td>进入到容器内部，进行修改容器内的内容  -it+名字+bash：添加一个可交互的终端。exit：退出</td>
</tr>
<tr>
<td>docker bulid</td>
<td>创建自定义的镜像</td>
</tr>
<tr>
<td>docker save</td>
<td>保存镜像到本地压缩文件</td>
</tr>
<tr>
<td>docker load</td>
<td>加载本地压缩文件到镜像</td>
</tr>
<tr>
<td>docker inspect</td>
<td>查看容器详细信息</td>
</tr>
</tbody>
</table>
<p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Docker开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"># Docker容器开机自启</span><br><span class="line">docker update --restart=always [容器名/容器id]</span><br></pre></td></tr></table></figure>
<h3 id="演示案例："><a href="#演示案例：" class="headerlink" title="演示案例："></a><strong>演示案例</strong>：</h3><p>查看DCokerHub，拉取Nginx镜像，创建并运行Nginx容器</p>
<p>需求：</p>
<ul>
<li>在DCokerHub中搜索Nginx镜像，查看镜像的名称</li>
<li>拉取Nginx镜像</li>
<li>查看本地镜像列表</li>
<li>创建并运行Nginx容器</li>
<li>查看容器</li>
<li>停止容器</li>
<li>再次启动容器</li>
<li>进入Nginx容器</li>
<li>删除容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span><br><span class="line"></span><br><span class="line"># 第2步，拉取Nginx镜像</span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"># 第3步，查看镜像</span><br><span class="line">docker images</span><br><span class="line"># 结果如下：</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    605c77e624dd   16 months ago   141MB</span><br><span class="line">mysql        latest    3218b38490ce   17 months ago   516MB</span><br><span class="line"></span><br><span class="line"># 第4步，创建并允许Nginx容器</span><br><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br><span class="line"></span><br><span class="line"># 第5步，查看运行中容器</span><br><span class="line">docker ps</span><br><span class="line"># 也可以加格式化方式访问，格式会更加清爽</span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 第6步，访问网页，地址：http://虚拟机地址</span><br><span class="line"></span><br><span class="line"># 第7步，停止容器</span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"># 第8步，查看所有容器</span><br><span class="line">docker ps -a --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 第9步，再次启动nginx容器</span><br><span class="line">docker start nginx</span><br><span class="line"></span><br><span class="line"># 第10步，再次查看容器</span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 第11步，查看容器详细信息</span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"># 第12步，进入容器,查看容器内目录</span><br><span class="line">docker exec -it nginx bash</span><br><span class="line"># 或者，可以进入MySQL</span><br><span class="line">docker exec -it mysql mysql -uroot -p</span><br><span class="line"></span><br><span class="line"># 第13步，删除容器</span><br><span class="line">docker rm nginx</span><br><span class="line"># 发现无法删除，因为容器运行中，强制删除容器</span><br><span class="line">docker rm -f nginx</span><br></pre></td></tr></table></figure>
<h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>给常用Docker命令起别名，方便我们访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 修改/root/.bashrc文件</span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"># .bashrc</span><br><span class="line"></span><br><span class="line"># User specific aliases and functions</span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span><br><span class="line">alias dis=&#x27;docker images&#x27;</span><br><span class="line"></span><br><span class="line"># Source global definitions</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>然后，执行命令使别名生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。大家思考几个问题：</p>
<ul>
<li>如果要升级MySQL版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li>
<li>MySQL、Nginx容器运行后，如果我要修改其中的某些配置该怎么办？</li>
<li>我想要让Nginx代理我的静态资源怎么办？</li>
</ul>
<p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p>
<p><strong>数据卷（volume）</strong>是一个<strong>虚拟目录</strong>，是<strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。</p>
<p>以Nginx为例，我们知道Nginx中有 两个关键的目录：</p>
<ul>
<li><code>html</code>：放置一些静态资源</li>
<li><code>conf</code>：放置配置文件</li>
</ul>
<p>如果我们要让Nginx代理我们的静态资源，最好是放到<code>html</code>目录；如果我们要修改Nginx的配置，最好是找到<code>conf</code>下的<code>nginx.conf</code>文件。</p>
<p>但遗憾的是，容器运行的Nginx所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图</p>
<p><img src="D:\学习资料\实验室培训\运维\image\image-20250117165816320.png" alt="image-20250117165816320"></p>
<p>在上图中：</p>
<ul>
<li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li>
<li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li>
<li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li>
</ul>
<p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">/var/lib/docker/volumes这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为/数据卷名/_data。</span><br><span class="line"></span><br><span class="line">为什么不让容器目录直接指向宿主机目录呢？</span><br><span class="line">- 因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变了。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</span><br><span class="line">- 但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可。</span><br><span class="line"></span><br><span class="line">不过，我们通过由于数据卷目录比较深，不好寻找，通常我们也允许让容器直接与宿主机目录挂载而不使用数据卷。</span><br></pre></td></tr></table></figure>
<h3 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h3><p>数据卷的相关命令</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>命令</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">docker volume create</td>
<td style="text-align:left">创建数据卷</td>
</tr>
<tr>
<td style="text-align:left">docker volume ls</td>
<td style="text-align:left">查看所有数据卷</td>
</tr>
<tr>
<td style="text-align:left">docker volume rm</td>
<td style="text-align:left">删除指定数据卷</td>
</tr>
<tr>
<td style="text-align:left">docker volume inspect</td>
<td style="text-align:left">查看某个数据卷的详情</td>
</tr>
<tr>
<td style="text-align:left">docker volume prune</td>
<td style="text-align:left">清除数据卷</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>容器与数据卷的挂载要在<strong>创建容器时</strong>配置，对于创建好的容器，是不能设置数据卷的。在执行docker run命令时，使用<strong>-v 数据卷:容器内目录</strong>可以完成数据卷挂载。</li>
<li><strong>创建容器的过程中，如果挂载了数据卷且数据卷不存在，数据卷会自动创建</strong>。</li>
</ul>
<h4 id="演示案例1"><a href="#演示案例1" class="headerlink" title="演示案例1"></a>演示案例1</h4><p>利用Nginx容器部署静态资源</p>
<p>需求：</p>
<ul>
<li>创建Nginx容器，修改nginx容器内的html目录下的index.html文件内容</li>
<li>将静态资源部署到nginx的html目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span><br><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"># 2.然后查看数据卷</span><br><span class="line">docker volume ls</span><br><span class="line"># 结果</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"># 3.查看数据卷详情</span><br><span class="line">docker volume inspect html</span><br><span class="line"># 结果</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2024-05-17T19:57:08+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/html/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;html&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 4.查看/var/lib/docker/volumes/html/_data目录</span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"># 可以看到与nginx的html目录内容一样，结果如下：</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 497 12月 28 2021 50x.html</span><br><span class="line">-rw-r--r--. 1 root root 615 12月 28 2021 index.html</span><br><span class="line"></span><br><span class="line"># 5.进入该目录，并随意修改index.html内容</span><br><span class="line">cd /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"># 6.打开页面，查看效果</span><br><span class="line"></span><br><span class="line"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span><br><span class="line">docker exec -it nginx bash</span><br></pre></td></tr></table></figure>
<h4 id="演示案例2"><a href="#演示案例2" class="headerlink" title="演示案例2"></a>演示案例2</h4><p>mysql容器的数据挂载</p>
<p>需求：</p>
<ul>
<li>查看mysql容器，判断是否有数据卷挂载</li>
<li>基于宿主机目录实现MySQL数据目录、配置文件、初始化脚本的挂载（查阅官方镜像文档）</li>
</ul>
<h5 id="MySQL的匿名数据卷"><a href="#MySQL的匿名数据卷" class="headerlink" title="MySQL的匿名数据卷"></a>MySQL的匿名数据卷</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 1.查看MySQL容器详细信息</span><br><span class="line">docker inspect mysql</span><br><span class="line"># 关注其中.Config.Volumes部分和.Mounts部分</span><br></pre></td></tr></table></figure>
<p>我们关注两部分内容，第一是<code>.Config.Volumes</code>部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Config&quot;: &#123;</span><br><span class="line">    // ... 略</span><br><span class="line">    &quot;Volumes&quot;: &#123;</span><br><span class="line">      &quot;/var/lib/mysql&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ... 略</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是<strong>数据卷未定义</strong>。这就是匿名卷。</p>
<p>然后，我们再看结果中的<code>.Mounts</code>部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">      &quot;Name&quot;: &quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;,</span><br><span class="line">      &quot;Source&quot;: &quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;,</span><br><span class="line">      &quot;Destination&quot;: &quot;/var/lib/mysql&quot;,</span><br><span class="line">      &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，其中有几个关键属性：</p>
<ul>
<li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。</li>
<li>Source：宿主机目录</li>
<li>Destination : 容器内的目录</li>
</ul>
<p>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p>
<p>接下来，可以查看该目录下的MySQL的data文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</span><br></pre></td></tr></table></figure>
<p>注意：每一个不同的镜像，将来创建容器后内部有哪些目录可以挂载，可以参考DockerHub对应的页面</p>
<h3 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h3><p>数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在执行docker run命令时：</span><br><span class="line"># 挂载本地目录</span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"># 挂载本地文件</span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql # 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span><br><span class="line">-v ./mysql:/var/lib/mysql # 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span><br></pre></td></tr></table></figure>
<h5 id="删除并重新创建mysql容器，并完成本地目录挂载："><a href="#删除并重新创建mysql容器，并完成本地目录挂载：" class="headerlink" title="删除并重新创建mysql容器，并完成本地目录挂载："></a>删除并重新创建mysql容器，并完成本地目录挂载：</h5><ul>
<li>挂载<code>/root/mysql/data</code>到容器内的<code>/var/lib/mysql</code>目录</li>
<li>挂载<code>/root/mysql/init</code>到容器内的<code>/docker-entrypoint-initdb.d</code>目录（初始化的SQL脚本目录）</li>
<li>挂载<code>/root/mysql/conf</code>到容器内的<code>/etc/mysql/conf.d</code>目录（这个是MySQL配置文件目录）</li>
</ul>
<h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure>
<ul>
<li><p>docker run  ：创建并运行一个容器</p>
</li>
<li><p><strong>-d</strong> 是让容器在后台运行</p>
</li>
<li><p><strong>–name</strong> ：给容器起个名字，<strong>必须唯一</strong></p>
</li>
<li><p><strong>-p 3306:3306</strong>  ：设置端口映射</p>
<ul>
<li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li>
<li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li>
<li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li>
</ul>
</li>
<li><p><strong>-e KEY=VALUE</strong> ：设置环境变量   （配置容器内进程运行时的一些参数）</p>
<ul>
<li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li>
<li>案例中，<code>TZ`</code>=Asia/Shanghai<code>是设置时区；</code>MYSQL_ROOT_PASSWORD=123`是设置MySQL默认密码</li>
</ul>
</li>
<li><p><strong>mysql</strong>  ：指定运行的镜像的名字</p>
<ul>
<li><p><strong>镜像命令规范</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">镜像名称一般分为两部分组成：[repository]:[tag]</span><br><span class="line">repository是镜像名称</span><br><span class="line">tag是镜像的版本</span><br><span class="line">如：mysql:5.7</span><br><span class="line">在没有指定tag时，默认时Latest,代表最新版本的镜像</span><br></pre></td></tr></table></figure>
<p>镜像的名称不是随意的，而是要到DockerRegistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在DockerHub网站或者软件的官方网站中都能找到。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2025/01/16/git%E5%92%8Cdocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="next" title="git和docker常用命令">
                <i class="fa fa-chevron-left"></i> git和docker常用命令
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.</span> <span class="nav-text">常见命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.1.</span> <span class="nav-text">命令介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.1.2.</span> <span class="nav-text">演示案例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D"><span class="nav-number">1.1.3.</span> <span class="nav-text">命令别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">1.2.</span> <span class="nav-text">数据卷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.2.</span> <span class="nav-text">数据卷命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B1"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">演示案例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B2"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">演示案例2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL%E7%9A%84%E5%8C%BF%E5%90%8D%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">MySQL的匿名数据卷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.3.</span> <span class="nav-text">挂载本地目录或文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%B9%B6%E9%87%8D%E6%96%B0%E5%88%9B%E5%BB%BAmysql%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%B9%B6%E5%AE%8C%E6%88%90%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD%EF%BC%9A"><span class="nav-number">1.2.3.0.1.</span> <span class="nav-text">删除并重新创建mysql容器，并完成本地目录挂载：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="nav-number">1.3.</span> <span class="nav-text">自定义镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">1.4.</span> <span class="nav-text">网络</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2"><span class="nav-number">2.</span> <span class="nav-text">部署</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E9%83%A8%E7%BD%B2"><span class="nav-number">2.1.</span> <span class="nav-text">MySQL部署</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">代洪嵩</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
